from ignition.service.framework import Capability, Service, interface
from ignition.service.config import ConfigurationPropertiesGroup
from ignition.service.api import BaseController
from ignition.model.lifecycle import LifecycleExecution, lifecycle_execution_dict, STATUS_COMPLETE, STATUS_FAILED
from ignition.service.messaging import Message, Envelope, JsonContent, TopicConfigProperties
from ignition.model.lifecycle import LifecycleExecuteResponse
from ignition.utils.file import DirectoryTree
from ignition.api.exceptions import ApiException
from ignition.service.logging import logging_context
from ignition.utils.propvaluemap import PropValueMap
import uuid
import logging
import os
import zipfile
import shutil
import base64
import pathlib
import ignition.openapi as openapi

logger = logging.getLogger(__name__)
# Grabs the __init__.py from the openapi package then takes it's parent, the openapi directory itself
openapi_path = str(pathlib.Path(openapi.__file__).parent.resolve())

class LifecycleError(ApiException):
    status_code = 500

class TemporaryLifecycleError(LifecycleError):
    status_code = 503

class LifecycleExecutionRequestNotFoundError(LifecycleError):
    status_code = 400

class InvalidLifecycleScriptsError(LifecycleError):
    status_code = 400

class InvalidLifecycleNameError(LifecycleError):
    status_code = 400


class LifecycleProperties(ConfigurationPropertiesGroup, Service, Capability):

    def __init__(self):
        super().__init__('lifecycle')
        self.api_spec = os.path.join(openapi_path, 'vnfc_lifecycle.yaml')
        self.async_messaging_enabled = True
        self.scripts_workspace = './scripts_workspace'
        self.request_queue = LifecycleRequestQueueProperties()


class LifecycleRequestQueueProperties(ConfigurationPropertiesGroup, Service, Capability):
    """
    Configuration related to the request queue

    Attributes:
    - enabled:
            is the request queue enabled?
    - group_id:
            Kafka consumer group_id for the request queue
                (default: request_queue_consumer)
    - topic:
            Kafka request queue topic configuration
    """

    def __init__(self):
        super().__init__('request_queue')
        self.enabled = False
        self.group_id = "request_queue_consumer"
        # name intentionally not set so that it can be constructed per-driver
        self.topic = TopicConfigProperties(auto_create=True, num_partitions=20, config={'retention.ms': 60000, 'message.timestamp.difference.max.ms': 60000, 'file.delete.delay.ms': 60000})
        self.failed_topic = TopicConfigProperties(auto_create=True, num_partitions=1, config={})


class LifecycleDriverCapability(Capability):

    @interface
    def execute_lifecycle(self, lifecycle_name, lifecycle_scripts_tree, system_properties, properties, deployment_location):
        """
        Execute a lifecycle transition/operation for a Resource.
        This method should return immediate response of the request being accepted,
        it is expected that the LifecycleService will poll get_lifecycle_execution on this driver to determine when the request has completed (or devise your own method).

        :param str lifecycle_name: name of the lifecycle transition/operation to execute
        :param ignition.utils.file.DirectoryTree lifecycle_scripts_tree: object for navigating the directory of the lifecycle scripts for the Resource. The user should call "remove_all" when the files are no longer needed
        :param ignition.utils.propvaluemap.PropValueMap system_properties: properties generated by LM for this Resource: resourceId, resourceName, requestId, metricKey, resourceManagerId, deploymentLocation, resourceType
        :param ignition.utils.propvaluemap.PropValueMap properties: property values of the Resource
        :param dict deployment_location: the deployment location the Resource is assigned to
        :return: an ignition.model.lifecycle.LifecycleExecuteResponse

        :raises:
            ignition.service.lifecycle.InvalidLifecycleScriptsError: if the scripts are not valid
            ignition.service.lifecycle.InvalidLifecycleNameError: if no script can be found to execute the transition/operation given by lifecycle_name
            ignition.service.lifecycle.TemporaryLifecycleError: there is an issue handling this request at this time
            ignition.service.lifecycle.LifecycleError: there was an error handling this request
        """
        pass

    @interface
    def get_lifecycle_execution(self, request_id, deployment_location):
        """
        Retreive the status of a lifecycle transition/operation request

        :param str request_id: identifier of the request to check
        :param dict deployment_location: the deployment location the Resource is assigned to
        :return: an ignition.model.lifecycle.LifecycleExecution
        
        :raises:
            ignition.service.lifecycle.LifecycleExecutionRequestNotFoundError: if no request with the given request_id exists
            ignition.service.lifecycle.TemporaryLifecycleError: there is an issue handling this request at this time, an attempt should be made again at a later time
            ignition.service.lifecycle.LifecycleError: there was an error handling this request
        """
        pass

class LifecycleApiCapability(Capability):

    @interface
    def execute(self, **kwarg):
        pass


class LifecycleServiceCapability(Capability):

    @interface
    def execute_lifecycle(self, lifecycle_name, lifecycle_scripts, system_properties, properties, deployment_location):
        pass


class LifecycleScriptFileManagerCapability(Capability):

    @interface
    def build_tree(self, tree_name, lifecycle_scripts):
        pass


class LifecycleExecutionMonitoringCapability(Capability):

    @interface
    def monitor_execution(self, request_id, deployment_location):
        pass


class LifecycleMessagingCapability(Capability):

    @interface
    def send_lifecycle_execution(self, execution_task):
        pass


class LifecycleApiService(Service, LifecycleApiCapability, BaseController):
    """
    Out-of-the-box controller for the Lifecycle API
    """

    def __init__(self, **kwargs):
        if 'service' not in kwargs:
            raise ValueError('No service instance provided')
        self.service = kwargs.get('service')

    def execute(self, **kwarg):
        try:
            logging_context.set_from_headers()

            body = self.get_body(kwarg)
            logger.debug('Handling lifecycle execution request with body %s', body)
            lifecycle_name = self.get_body_required_field(body, 'lifecycleName')
            lifecycle_scripts = self.get_body_required_field(body, 'lifecycleScripts')
            system_properties = self.get_body_required_field(body, 'systemProperties')
            properties = self.get_body_field(body, 'properties', {})
            deployment_location = self.get_body_required_field(body, 'deploymentLocation')
            execute_response = self.service.execute_lifecycle(lifecycle_name, lifecycle_scripts, system_properties, properties, deployment_location)
            response = {'requestId': execute_response.request_id}
            return (response, 202)
        finally:
            logging_context.clear()

class LifecycleService(Service, LifecycleServiceCapability):
    """
    Out-of-the-box service for the Lifecycle API
    """

    def __init__(self, **kwargs):
        if 'driver' not in kwargs:
            raise ValueError('driver argument not provided')
        if 'lifecycle_config' not in kwargs:
            raise ValueError('lifecycle_config argument not provided')
        if 'script_file_manager' not in kwargs:
            raise ValueError('script_file_manager argument not provided')
        self.driver = kwargs.get('driver')
        self.script_file_manager = kwargs.get('script_file_manager')
        lifecycle_config = kwargs.get('lifecycle_config')
        self.async_enabled = lifecycle_config.async_messaging_enabled
        if self.async_enabled is True:
            if 'lifecycle_monitor_service' not in kwargs:
                raise ValueError('lifecycle_monitor_service argument not provided (required when async_messaging_enabled is True)')
            self.lifecycle_monitor_service = kwargs.get('lifecycle_monitor_service')
        self.async_requests_enabled = lifecycle_config.request_queue.enabled
        if self.async_requests_enabled:
            if 'request_queue' not in kwargs:
                raise ValueError('request_queue argument not provided (required when async_requests_enabled is True)')
            self.request_queue = kwargs.get('request_queue')

    def execute_lifecycle(self, lifecycle_name, lifecycle_scripts, system_properties, properties, deployment_location):
        if self.async_requests_enabled:
            request_id = str(uuid.uuid4())
            self.request_queue.queue_lifecycle_request({
                'request_id': request_id,
                'lifecycle_name': lifecycle_name,
                'lifecycle_scripts': lifecycle_scripts,
                'system_properties': system_properties,
                'properties': properties,
                'deployment_location': deployment_location
            })
            execute_response = LifecycleExecuteResponse(request_id)
        else:
            file_name = '{0}'.format(str(uuid.uuid4()))
            lifecycle_scripts_tree = self.script_file_manager.build_tree(file_name, lifecycle_scripts)
            execute_response = self.driver.execute_lifecycle(lifecycle_name, lifecycle_scripts_tree, PropValueMap(system_properties), PropValueMap(properties), deployment_location)
            if self.async_enabled is True:
                self.__async_lifecycle_execution_completion(execute_response.request_id, deployment_location)

        return execute_response

    def __async_lifecycle_execution_completion(self, request_id, deployment_location):
        self.lifecycle_monitor_service.monitor_execution(request_id, deployment_location)


LIFECYCLE_EXECUTION_MONITOR_JOB_TYPE = 'LifecycleExecutionMonitoring'


class LifecycleExecutionMonitoringService(Service, LifecycleExecutionMonitoringCapability):

    def __init__(self, **kwargs):
        if 'job_queue_service' not in kwargs:
            raise ValueError('job_queue_service argument not provided')
        if 'lifecycle_messaging_service' not in kwargs:
            raise ValueError('lifecycle_messaging_service argument not provided')
        if 'driver' not in kwargs:
            raise ValueError('driver argument not provided')
        self.job_queue_service = kwargs.get('job_queue_service')
        self.lifecycle_messaging_service = kwargs.get('lifecycle_messaging_service')
        self.driver = kwargs.get('driver')
        self.job_queue_service.register_job_handler(LIFECYCLE_EXECUTION_MONITOR_JOB_TYPE, self.job_handler)

    def job_handler(self, job_definition):
        if 'request_id' not in job_definition or job_definition['request_id'] is None:
            logger.warning('Job with {0} job type is missing request_id. This job has been discarded'.format(LIFECYCLE_EXECUTION_MONITOR_JOB_TYPE))
            return True
        if 'deployment_location' not in job_definition or job_definition['deployment_location'] is None:
            logger.warning('Job with {0} job type is missing deployment_location. This job has been discarded'.format(LIFECYCLE_EXECUTION_MONITOR_JOB_TYPE))
            return True
        request_id = job_definition['request_id']
        deployment_location = job_definition['deployment_location']
        try:
            lifecycle_execution_task = self.driver.get_lifecycle_execution(request_id, deployment_location)
        except LifecycleExecutionRequestNotFoundError as e:
            logger.debug('Request with ID {0} not found, the request will no longer be monitored'.format(request_id))
            return True
        except TemporaryLifecycleError as e:
            logger.exception('Temporary error occurred checking status of request with ID {0}. The monitoring job will be re-queued: {1}'.format(request_id, str(e)))
            return False
        status = lifecycle_execution_task.status
        if status in [STATUS_COMPLETE, STATUS_FAILED]:
            self.lifecycle_messaging_service.send_lifecycle_execution(lifecycle_execution_task)
            return True
        return False

    def __create_job_definition(self, request_id, deployment_location):
        return {
            'job_type': LIFECYCLE_EXECUTION_MONITOR_JOB_TYPE,
            'request_id': request_id,
            'deployment_location': deployment_location
        }

    def monitor_execution(self, request_id, deployment_location):
        if request_id is None:
            raise ValueError('Cannot monitor task when request_id is not given')
        if deployment_location is None:
            raise ValueError('Cannot monitor task when deployment_location is not given')
        self.job_queue_service.queue_job(self.__create_job_definition(request_id, deployment_location))


class LifecycleMessagingService(Service, LifecycleMessagingCapability):

    def __init__(self, **kwargs):
        if 'postal_service' not in kwargs:
            raise ValueError('postal_service argument not provided')
        if 'topics_configuration' not in kwargs:
            raise ValueError('topics_configuration argument not provided')
        self.postal_service = kwargs.get('postal_service')
        topics_configuration = kwargs.get('topics_configuration')
        if topics_configuration.lifecycle_execution_events is None:
            raise ValueError('lifecycle_execution_events topic must be set')
        self.lifecycle_execution_events_topic = topics_configuration.lifecycle_execution_events.name
        if self.lifecycle_execution_events_topic is None:
            raise ValueError('lifecycle_execution_events topic name must be set')

    def send_lifecycle_execution(self, lifecycle_execution):
        if lifecycle_execution is None:
            raise ValueError('lifecycle_execution must be set to send an lifecycle execution event')
        lifecycle_execution_message_content = lifecycle_execution_dict(lifecycle_execution)
        message_str = JsonContent(lifecycle_execution_message_content).get()
        self.postal_service.post(Envelope(self.lifecycle_execution_events_topic, Message(message_str)))

class LifecycleScriptFileManagerService(Service, LifecycleScriptFileManagerCapability):

    def __init__(self, **kwargs):
        if 'lifecycle_config' not in kwargs:
            raise ValueError('lifecycle_config argument not provided')
        lifecycle_config = kwargs.get('lifecycle_config')
        self.scripts_workspace = lifecycle_config.scripts_workspace
        if self.scripts_workspace is None:
            raise ValueError('scripts_workspace directory must be set')
        self.__create_workspace_if_needed()

    def __create_workspace_if_needed(self):
        if not os.path.exists(self.scripts_workspace):
            os.makedirs(self.scripts_workspace)

    def build_tree(self, tree_name, lifecycle_scripts):
        self.__clear_existing_files(tree_name)
        package_path = self.__write_scripts_to_disk(tree_name, lifecycle_scripts)
        extracted_path = self.__extract_scripts(tree_name, package_path)
        return DirectoryTree(extracted_path)

    def __clear_existing_files(self, tree_name):
        package_write_path = self.__determine_package_path(tree_name)
        if os.path.exists(package_write_path):
            os.remove(package_write_path)
        extracted_path = self.__determine_extracted_path(tree_name)
        if os.path.exists(extracted_path):
            shutil.rmtree(extracted_path)

    def __determine_package_path(self, tree_name):
        package_write_path = os.path.join(self.scripts_workspace, '{0}.zip'.format(tree_name))
        return package_write_path

    def __determine_extracted_path(self, tree_name):
        extracted_path = os.path.join(self.scripts_workspace, tree_name)
        return extracted_path

    def __write_scripts_to_disk(self, tree_name, lifecycle_scripts):
        package_write_path = self.__determine_package_path(tree_name)
        with open(package_write_path, 'wb') as package_writer:
            package_writer.write(base64.b64decode(lifecycle_scripts))
        return package_write_path

    def __extract_scripts(self, tree_name, package_path):
        if not zipfile.is_zipfile(package_path):
            raise ValueError('lifecycle_scripts should include binary contents of a zip file')
        extracted_path = self.__determine_extracted_path(tree_name)
        with zipfile.ZipFile(package_path, 'r') as package_zip:
            package_zip.extractall(extracted_path)
        os.remove(package_path)
        return extracted_path


from .base import Component
from .value import serialize_privacy_usage

# Warning, this file is autogenerated by code_generation.py. Don't modify this manually.


def abs(data, **kwargs):
    """
    Abs Component
    
    :param data: 
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: 
    """
    return Component(
        "Abs",
        arguments={
            'data': Component.of(data)
        },
        options={
            
        },
        constraints=kwargs)


def add(left, right, **kwargs):
    """
    Add Component
    
    :param left: 
    :param right: 
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: 
    """
    return Component(
        "Add",
        arguments={
            'left': Component.of(left),
            'right': Component.of(right)
        },
        options={
            
        },
        constraints=kwargs)


def logical_and(left, right, **kwargs):
    """
    And Component
    
    :param left: 
    :param right: 
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: 
    """
    return Component(
        "And",
        arguments={
            'left': Component.of(left),
            'right': Component.of(right)
        },
        options={
            
        },
        constraints=kwargs)


def cast(data, atomic_type, true_label=None, lower=None, upper=None, **kwargs):
    """
    Cast Component
    
    Cast data to an atomic type.
    
    :param data: Data to be cast to another type.
    :param true_label: Positive class (class to be mapped to `true`) for each column. Used only if casting to `bool`.
    :param lower: Minimum allowable imputation value. Used only if casting to `i64`.
    :param upper: Maximum allowable imputation value. Used only if casting to `i64`.
    :param atomic_type: Type to which data should be cast. One of [`string`, `int`, `bool`, `float`]
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: 
    """
    return Component(
        "Cast",
        arguments={
            'data': Component.of(data),
            'true_label': Component.of(true_label),
            'lower': Component.of(lower),
            'upper': Component.of(upper)
        },
        options={
            'atomic_type': atomic_type
        },
        constraints=kwargs)


def clamp(data, lower=None, upper=None, categories=None, null_value=None, **kwargs):
    """
    Clamp Component
    
    Clamps data to the provided bounds.
    
    If data are numeric, clamping maps elements outside of an interval `[lower, upper]` to the closer endpoint.
    If data are categorical, clamping maps elements outside of the `categories` argument to the associated `null`.
    Using clamp sets the `categories` property for the analysis with value `categories` plus `null_value` in the last position.
    
    :param data: Data to be clamped.
    :param lower: Desired lower bound for each column of the data. Used only if `categories` is `None`.
    :param upper: Desired upper bound for each column of the data. Used only if `categories` is `None`.
    :param categories: The set of categories you want to be represented for each column of the data.
    :param null_value: The value to which elements not included in `categories` will be mapped for each column of the data. Used only if `categories` is not `None`.
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: Clamped data.
    """
    return Component(
        "Clamp",
        arguments={
            'data': Component.of(data),
            'lower': Component.of(lower),
            'upper': Component.of(upper),
            'categories': Component.of(categories, value_format="jagged"),
            'null_value': Component.of(null_value)
        },
        options={
            
        },
        constraints=kwargs)


def count(data, **kwargs):
    """
    Count Component
    
    Returns the number of rows in the data.
    
    :param data: 
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: 
    """
    return Component(
        "Count",
        arguments={
            'data': Component.of(data)
        },
        options={
            
        },
        constraints=kwargs)


def covariance(data=None, left=None, right=None, finite_sample_correction=True, **kwargs):
    """
    Covariance Component
    
    Calculate covariance.
    
    If `data` argument is provided as a 2D array, calculate covariance matrix. Otherwise, `left` and `right` 1D arrays are used to calculate a cross-covariance matrix between elements of the two arrays.
    
    :param data: 2D data array used to construct covariance matrix.
    :param left: Left data array used to calculate cross-covariance matrix. Used only if `data` not provided.
    :param right: Right data array used to calculate cross-covariance matrix. Used only if `data` not provided.
    :param finite_sample_correction: Whether or not to use the finite sample correction (Bessel's correction).
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: Flattened covariance or cross-covariance matrix.
    """
    return Component(
        "Covariance",
        arguments={
            'data': Component.of(data),
            'left': Component.of(left),
            'right': Component.of(right)
        },
        options={
            'finite_sample_correction': finite_sample_correction
        },
        constraints=kwargs)


def dp_count(data, lower=0, upper=None, mechanism="SimpleGeometric", privacy_usage=None, enforce_constant_time=False, **kwargs):
    """
    DPCount Component
    
    Returns a differentially private row count.
    
    :param data: 
    :param lower: Estimated minimum possible size of the data.
    :param upper: Estimated maximum possible size of the data.
    :param mechanism: Privatizing mechanism to use. One of [`SimpleGeometric`, `Laplace`, `Gaussian`]
    :param privacy_usage: Object describing the type and amount of privacy to be used for the mechanism release.
    :param enforce_constant_time: Whether or not to require Geometric mechanism to run in constant time.
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: Differentially private row count.
    """
    return Component(
        "DPCount",
        arguments={
            'data': Component.of(data),
            'lower': Component.of(lower),
            'upper': Component.of(upper)
        },
        options={
            'mechanism': mechanism,
            'privacy_usage': serialize_privacy_usage(privacy_usage),
            'enforce_constant_time': enforce_constant_time
        },
        constraints=kwargs)


def dp_covariance(left=None, right=None, data=None, mechanism="Laplace", privacy_usage=None, finite_sample_correction=True, **kwargs):
    """
    DPCovariance Component
    
    Calculate differentially private covariance.
    
    If `data` argument is provided as a 2D array, calculate covariance matrix. Otherwise, `left` and `right` 1D arrays are used to calculate a cross-covariance matrix between elements of the two arrays.
    
    :param left: Left data array used to calculate cross-covariance matrix. Used only if `data` not provided.
    :param right: Right data array used to calculate cross-covariance matrix. Used only if `data` not provided.
    :param data: 2D data array used to construct covariance matrix.
    :param mechanism: Privatizing mechanism to use. One of [`Laplace`, `Gaussian`]
    :param privacy_usage: Object describing the type and amount of privacy to be used for the mechanism release.
    :param finite_sample_correction: Whether or not to use the finite sample correction (Bessel's correction).
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: Flattened covariance or cross-covariance matrix.
    """
    return Component(
        "DPCovariance",
        arguments={
            'left': Component.of(left),
            'right': Component.of(right),
            'data': Component.of(data)
        },
        options={
            'mechanism': mechanism,
            'privacy_usage': serialize_privacy_usage(privacy_usage),
            'finite_sample_correction': finite_sample_correction
        },
        constraints=kwargs)


def dp_histogram(data, edges=None, categories=None, null_value=None, lower=0, upper=None, inclusive_left=True, mechanism="SimpleGeometric", privacy_usage=None, enforce_constant_time=False, **kwargs):
    """
    DPHistogram Component
    
    Returns a differentially private histogram over user-defined categories. The final cell contains the counts for null values (outside the set of categories).
    
    :param data: 
    :param edges: Set of edges to bin continuous-valued data. Used only if data are of `continuous` nature.
    :param categories: Set of categories in data. Used only if data are of `categorical` nature.
    :param null_value: The value to which elements not included in `categories` will be mapped for each column of the data. Used only if `categories` is not `None`. The null value is the final category- counts for the null category are at the end of the vector of counts.
    :param lower: Estimated minimum possible size of bin counts.
    :param upper: Estimated maximum possible size of bin counts.
    :param inclusive_left: Whether or not the left edge of the bin is inclusive. If `true` bins are of the form [lower, upper). Otherwise, bins are of the form (lower, upper]. Used only if data are of `continuous` nature.
    :param mechanism: Privatizing mechanism to use. One of [`SimpleGeometric`, `Laplace`, `Gaussian`]
    :param privacy_usage: Object describing the type and amount of privacy to be used for the mechanism release.
    :param enforce_constant_time: Whether or not to require Geometric mechanism to run in constant time.
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: Differentially private histogram.
    """
    return Component(
        "DPHistogram",
        arguments={
            'data': Component.of(data),
            'edges': Component.of(edges, value_format="jagged"),
            'categories': Component.of(categories, value_format="jagged"),
            'null_value': Component.of(null_value),
            'lower': Component.of(lower),
            'upper': Component.of(upper),
            'inclusive_left': Component.of(inclusive_left)
        },
        options={
            'mechanism': mechanism,
            'privacy_usage': serialize_privacy_usage(privacy_usage),
            'enforce_constant_time': enforce_constant_time
        },
        constraints=kwargs)


def dp_maximum(data, mechanism="Laplace", privacy_usage=None, **kwargs):
    """
    DPMaximum Component
    
    Returns differentially private estimates of the maximum elements of each column of the data.
    
    :param data: 
    :param mechanism: Privatizing mechanism to use. One of [`Laplace`, `Gaussian`]
    :param privacy_usage: Object describing the type and amount of privacy to be used for the mechanism release.
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: Differentially private estimates of the maximum elements of the data.
    """
    return Component(
        "DPMaximum",
        arguments={
            'data': Component.of(data)
        },
        options={
            'mechanism': mechanism,
            'privacy_usage': serialize_privacy_usage(privacy_usage)
        },
        constraints=kwargs)


def dp_mean(data, implementation="resized", mechanism="Laplace", privacy_usage=None, **kwargs):
    """
    DPMean Component
    
    Returns differentially private estimates of the means of each column of the data.
    
    :param data: 
    :param implementation: Privatizing algorithm to use. One of [`resized`, `plug-in`]
    :param mechanism: Privatizing mechanism to use. One of [`Laplace`, `Gaussian`]
    :param privacy_usage: Object describing the type and amount of privacy to be used for the mechanism release.
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: Differentially private estimate of the mean of each column of the data.
    """
    return Component(
        "DPMean",
        arguments={
            'data': Component.of(data)
        },
        options={
            'implementation': implementation,
            'mechanism': mechanism,
            'privacy_usage': serialize_privacy_usage(privacy_usage)
        },
        constraints=kwargs)


def dp_median(data, mechanism='Laplace', privacy_usage=None, interpolation="midpoint", **kwargs):
    """
    DPMedian Component
    
    Returns differentially private estimates of the median of each column of the data.
    
    :param data: 
    :param mechanism: Privatizing mechanism to use.
    :param privacy_usage: Object describing the type and amount of privacy to be used for the mechanism release.
    :param interpolation: Interpolation strategy. One of [`lower`, `upper`, `midpoint`, `nearest`, `linear`]
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: Differentially private estimates of the median of each column of the data.
    """
    return Component(
        "DPMedian",
        arguments={
            'data': Component.of(data)
        },
        options={
            'mechanism': mechanism,
            'privacy_usage': serialize_privacy_usage(privacy_usage),
            'interpolation': interpolation
        },
        constraints=kwargs)


def dp_minimum(data, mechanism="Laplace", privacy_usage=None, **kwargs):
    """
    DPMinimum Component
    
    Returns differentially private estimates of the minimum elements of each column of the data.
    
    :param data: 
    :param mechanism: Privatizing mechanism to use. One of [`Laplace`, `Gaussian`]
    :param privacy_usage: Object describing the type and amount of privacy to be used for the mechanism release.
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: Differentially private estimates of the minimum elements of the data.
    """
    return Component(
        "DPMinimum",
        arguments={
            'data': Component.of(data)
        },
        options={
            'mechanism': mechanism,
            'privacy_usage': serialize_privacy_usage(privacy_usage)
        },
        constraints=kwargs)


def dp_moment_raw(data, order, mechanism="Laplace", privacy_usage=None, **kwargs):
    """
    DPMomentRaw Component
    
    Returns sample estimate of a raw moment for each column of the data.
    
    :param data: 
    :param order: Integer statistical moment indicator.
    :param mechanism: Privatizing mechanism to use. One of [`Laplace`, `Gaussian`]
    :param privacy_usage: Object describing the type and amount of privacy to be used for the mechanism release.
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: Sample estimate of raw moment for each column of the data.
    """
    return Component(
        "DPMomentRaw",
        arguments={
            'data': Component.of(data)
        },
        options={
            'order': order,
            'mechanism': mechanism,
            'privacy_usage': serialize_privacy_usage(privacy_usage)
        },
        constraints=kwargs)


def dp_sum(data, lower=None, upper=None, mechanism="Laplace", privacy_usage=None, **kwargs):
    """
    DPSum Component
    
    Returns differentially private estimates of the sums of each column of the data.
    
    :param data: 
    :param lower: Estimated minimum possible sum for the geometric mechanism, when doing an integer sum.
    :param upper: Estimated maximum possible sum for the geometric mechanism, when doing an integer sum.
    :param mechanism: Privatizing mechanism to use. One of [`Laplace`, `Gaussian`, `SimpleGeometric`]
    :param privacy_usage: Object describing the type and amount of privacy to be used for the mechanism release.
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: Differentially private sum over elements for each column of the data.
    """
    return Component(
        "DPSum",
        arguments={
            'data': Component.of(data),
            'lower': Component.of(lower),
            'upper': Component.of(upper)
        },
        options={
            'mechanism': mechanism,
            'privacy_usage': serialize_privacy_usage(privacy_usage)
        },
        constraints=kwargs)


def dp_variance(data, mechanism="Laplace", privacy_usage=None, finite_sample_correction=True, **kwargs):
    """
    DPVariance Component
    
    Returns a differentially private estimate of the variance for each column of the data.
    
    :param data: 
    :param mechanism: Privatizing mechanism to use. One of [`Laplace`, `Gaussian`]
    :param privacy_usage: Object describing the type and amount of privacy to be used for the mechanism release.
    :param finite_sample_correction: Whether or not to use the finite sample correction (Bessel's correction).
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: Differentially private sample variance for each column of the data.
    """
    return Component(
        "DPVariance",
        arguments={
            'data': Component.of(data)
        },
        options={
            'mechanism': mechanism,
            'privacy_usage': serialize_privacy_usage(privacy_usage),
            'finite_sample_correction': finite_sample_correction
        },
        constraints=kwargs)


def digitize(data, edges, null_value=None, inclusive_left=True, **kwargs):
    """
    Digitize Component
    
    Maps data to bins.
    
    Bins will be of the form [lower, upper) or (lower, upper]. The null value is the final category.
    
    :param data: Data to be binned.
    :param edges: Values representing the edges of bins.
    :param null_value: Value to which to map if there is no valid bin (e.g. if the element falls outside the bin range). The null value is the final category.
    :param inclusive_left: Whether or not the left edge of the bin is inclusive, i.e. the bins are of the form [lower, upper).
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: 
    """
    return Component(
        "Digitize",
        arguments={
            'data': Component.of(data),
            'edges': Component.of(edges, value_format="jagged"),
            'null_value': Component.of(null_value),
            'inclusive_left': Component.of(inclusive_left)
        },
        options={
            
        },
        constraints=kwargs)


def divide(left, right, **kwargs):
    """
    Divide Component
    
    :param left: 
    :param right: 
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: 
    """
    return Component(
        "Divide",
        arguments={
            'left': Component.of(left),
            'right': Component.of(right)
        },
        options={
            
        },
        constraints=kwargs)


def equal(left, right, **kwargs):
    """
    Equal Component
    
    :param left: 
    :param right: 
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: 
    """
    return Component(
        "Equal",
        arguments={
            'left': Component.of(left),
            'right': Component.of(right)
        },
        options={
            
        },
        constraints=kwargs)


def filter(data, mask, **kwargs):
    """
    Filter Component
    
    Filters data down into only the desired rows.
    
    :param data: 
    :param mask: Boolean mask giving whether or not each row should be kept.
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: Data with only the desired rows.
    """
    return Component(
        "Filter",
        arguments={
            'data': Component.of(data),
            'mask': Component.of(mask)
        },
        options={
            
        },
        constraints=kwargs)


def gaussian_mechanism(data, privacy_usage=None, **kwargs):
    """
    GaussianMechanism Component
    
    Privatizes a result by returning it perturbed with Gaussian noise.
    
    :param data: Result to be released privately via the Gaussian mechanism.
    :param privacy_usage: Object describing the type and amount of privacy to be used for the mechanism release.
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: Original data perturbed with Gaussian noise.
    """
    return Component(
        "GaussianMechanism",
        arguments={
            'data': Component.of(data)
        },
        options={
            'privacy_usage': serialize_privacy_usage(privacy_usage)
        },
        constraints=kwargs)


def greater_than(left, right, **kwargs):
    """
    GreaterThan Component
    
    :param left: 
    :param right: 
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: 
    """
    return Component(
        "GreaterThan",
        arguments={
            'left': Component.of(left),
            'right': Component.of(right)
        },
        options={
            
        },
        constraints=kwargs)


def histogram(data, edges=None, categories=None, null_value=None, inclusive_left=True, **kwargs):
    """
    Histogram Component
    
    :param data: 
    :param edges: Set of edges to bin continuous-valued data. Used only if data are of `continuous` nature.
    :param categories: Set of categories in data. Used only if data are of `categorical` nature.
    :param null_value: The value to which elements not included in `categories` will be mapped for each column of the data. Used only if `categories` is not `None`.
    :param inclusive_left: Whether or not the left edge of the bin is inclusive. If `true` bins are of the form [lower, upper). Otherwise, bins are of the form (lower, upper]. Used only if data are of `continuous` nature.
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: 
    """
    return Component(
        "Histogram",
        arguments={
            'data': Component.of(data),
            'edges': Component.of(edges, value_format="jagged"),
            'categories': Component.of(categories, value_format="jagged"),
            'null_value': Component.of(null_value),
            'inclusive_left': Component.of(inclusive_left)
        },
        options={
            
        },
        constraints=kwargs)


def impute(data, lower=None, upper=None, categories=None, weights=None, distribution=None, shift=None, scale=None, **kwargs):
    """
    Impute Component
    
    Replaces null values with draws from a specified distribution.
    
    If the `categories` argument is provided, the data are considered to be categorical regardless of atomic type and the elements provided in `null_value` will be replaced with those in `categories` according to `weights`.
    
    If the `categories` argument is not provided, the data are considered to be numeric and elements that are `f64::NAN` will be replaced according to the specified distribution.
    
    :param data: The data for which null values will be imputed.
    :param lower: A lower bound on data elements for each column. Used only if `categories` is `None`.
    :param upper: An upper bound on data elements for each column. Used only if `categories` is `None`.
    :param categories: The set of categories you want to be represented for each column of the data, if the data is categorical.
    :param weights: Optional. The weight of each category when imputing. Uniform weights are used if not specified.
    :param distribution: The distribution to be used when imputing records. Used only if `categories` is `None`.
    :param shift: The expectation of the Gaussian distribution to be used for imputation. Used only if `distribution` is `Gaussian`.
    :param scale: The standard deviation of the Gaussian distribution to be used for imputation. Used only if `distribution` is `Gaussian`.
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: Data with null values replaced by imputed values.
    """
    return Component(
        "Impute",
        arguments={
            'data': Component.of(data),
            'lower': Component.of(lower),
            'upper': Component.of(upper),
            'categories': Component.of(categories, value_format="jagged"),
            'weights': Component.of(weights, value_format="jagged"),
            'distribution': Component.of(distribution),
            'shift': Component.of(shift),
            'scale': Component.of(scale)
        },
        options={
            
        },
        constraints=kwargs)


def index(data, columns, **kwargs):
    """
    Index Component
    
    Index into data frames, partitions and arrays to retrieve homogeneously typed contiguous arrays
    
    :param data: 
    :param columns: 
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: 
    """
    return Component(
        "Index",
        arguments={
            'data': Component.of(data),
            'columns': Component.of(columns)
        },
        options={
            
        },
        constraints=kwargs)


def kth_raw_sample_moment(data, k, **kwargs):
    """
    KthRawSampleMoment Component
    
    Returns sample estimate of kth raw moment for each column of the data.
    
    :param data: Data for which you would like the kth raw moments.
    :param k: Integer statistical moment indicator.
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: kth raw sample moment for each column.
    """
    return Component(
        "KthRawSampleMoment",
        arguments={
            'data': Component.of(data)
        },
        options={
            'k': k
        },
        constraints=kwargs)


def laplace_mechanism(data, privacy_usage=None, **kwargs):
    """
    LaplaceMechanism Component
    
    Privatizes a result by returning it perturbed with Laplace noise.
    
    :param data: True value to be released privately via the Laplace mechanism.
    :param privacy_usage: Object describing the type and amount of privacy to be used for the mechanism release.
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: Original data perturbed with Laplace noise.
    """
    return Component(
        "LaplaceMechanism",
        arguments={
            'data': Component.of(data)
        },
        options={
            'privacy_usage': serialize_privacy_usage(privacy_usage)
        },
        constraints=kwargs)


def less_than(left, right, **kwargs):
    """
    LessThan Component
    
    :param left: 
    :param right: 
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: 
    """
    return Component(
        "LessThan",
        arguments={
            'left': Component.of(left),
            'right': Component.of(right)
        },
        options={
            
        },
        constraints=kwargs)


def literal(**kwargs):
    """
    Literal Component
    
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: 
    """
    return Component(
        "Literal",
        arguments={
            
        },
        options={
            
        },
        constraints=kwargs)


def log(data, base=2.71828, **kwargs):
    """
    Log Component
    
    :param data: 
    :param base: 
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: 
    """
    return Component(
        "Log",
        arguments={
            'data': Component.of(data),
            'base': Component.of(base)
        },
        options={
            
        },
        constraints=kwargs)


def materialize(column_names, data_source, public=False, dataset_id=None, skip_row=True, **kwargs):
    """
    Materialize Component
    
    Load a tabular frame from a data source
    
    :param column_names: 
    :param data_source: 
    :param public: 
    :param dataset_id: when set, data with unknown number of records may still conform to data with the same dataset_id
    :param skip_row: when set, skip the first line (header) in a csv
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: 
    """
    return Component(
        "Materialize",
        arguments={
            'column_names': Component.of(column_names)
        },
        options={
            'data_source': data_source,
            'public': public,
            'dataset_id': dataset_id,
            'skip_row': skip_row
        },
        constraints=kwargs)


def maximum(data, **kwargs):
    """
    Maximum Component
    
    Find the maximum value of each column in the data.
    
    :param data: Data for which you want the maximum value in each column.
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: Maximum of each column in the data.
    """
    return Component(
        "Maximum",
        arguments={
            'data': Component.of(data)
        },
        options={
            
        },
        constraints=kwargs)


def mean(data, **kwargs):
    """
    Mean Component
    
    Calculates the arithmetic mean of each column in the provided data.
    
    :param data: 
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: Arithmetic mean for each column of the data in question.
    """
    return Component(
        "Mean",
        arguments={
            'data': Component.of(data)
        },
        options={
            
        },
        constraints=kwargs)


def minimum(data, **kwargs):
    """
    Minimum Component
    
    Find the minimum value of each column in the data.
    
    :param data: Data for which you want the maximum value in each column.
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: Maximum of each column in the data.
    """
    return Component(
        "Minimum",
        arguments={
            'data': Component.of(data)
        },
        options={
            
        },
        constraints=kwargs)


def modulo(left, right, **kwargs):
    """
    Modulo Component
    
    :param left: 
    :param right: 
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: 
    """
    return Component(
        "Modulo",
        arguments={
            'left': Component.of(left),
            'right': Component.of(right)
        },
        options={
            
        },
        constraints=kwargs)


def multiply(left, right, **kwargs):
    """
    Multiply Component
    
    :param left: 
    :param right: 
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: 
    """
    return Component(
        "Multiply",
        arguments={
            'left': Component.of(left),
            'right': Component.of(right)
        },
        options={
            
        },
        constraints=kwargs)


def negate(data, **kwargs):
    """
    Negate Component
    
    :param data: 
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: 
    """
    return Component(
        "Negate",
        arguments={
            'data': Component.of(data)
        },
        options={
            
        },
        constraints=kwargs)


def negative(data, **kwargs):
    """
    Negative Component
    
    :param data: 
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: 
    """
    return Component(
        "Negative",
        arguments={
            'data': Component.of(data)
        },
        options={
            
        },
        constraints=kwargs)


def logical_or(left, right, **kwargs):
    """
    Or Component
    
    :param left: 
    :param right: 
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: 
    """
    return Component(
        "Or",
        arguments={
            'left': Component.of(left),
            'right': Component.of(right)
        },
        options={
            
        },
        constraints=kwargs)


def partition(data, num_partitions=None, by=None, **kwargs):
    """
    Partition Component
    
    Split the rows of data into either into k equally sized partitions, or by the categories of a vector
    
    :param data: 
    :param num_partitions: 
    :param by: 
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: 
    """
    return Component(
        "Partition",
        arguments={
            'data': Component.of(data),
            'num_partitions': Component.of(num_partitions),
            'by': Component.of(by)
        },
        options={
            
        },
        constraints=kwargs)


def power(data, radical, **kwargs):
    """
    Power Component
    
    :param data: 
    :param radical: 
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: 
    """
    return Component(
        "Power",
        arguments={
            'data': Component.of(data),
            'radical': Component.of(radical)
        },
        options={
            
        },
        constraints=kwargs)


def quantile(data, alpha, interpolation="midpoint", **kwargs):
    """
    Quantile Component
    
    Get values corresponding to specified quantiles for each column of the data.
    
    :param data: 
    :param alpha: Desired quantiles, defined on `[0,1]`.
    :param interpolation: Interpolation strategy. One of [`lower`, `upper`, `midpoint`, `nearest`, `linear`]
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: Quantile values for each column.
    """
    return Component(
        "Quantile",
        arguments={
            'data': Component.of(data)
        },
        options={
            'alpha': alpha,
            'interpolation': interpolation
        },
        constraints=kwargs)


def reshape(data, shape, symmetric=False, layout='row', **kwargs):
    """
    Reshape Component
    
    Reshapes a row vector into a matrix.
    
    :param data: Vector of data to stack into a matrix. A Hashmap of matrices will be emitted if multiple rows are provided.
    :param symmetric: Set if data are elements from the upper triangle of a symmetric matrix.
    :param layout: Consecutive elements of either the `row` or `column` reside next to each other.
    :param shape: The shape of the output matrix.
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: Reshape of data.
    """
    return Component(
        "Reshape",
        arguments={
            'data': Component.of(data)
        },
        options={
            'symmetric': symmetric,
            'layout': layout,
            'shape': shape
        },
        constraints=kwargs)


def resize(data, n, lower=None, upper=None, categories=None, weights=None, distribution=None, shift=None, scale=None, **kwargs):
    """
    Resize Component
    
    Resizes the data in question to be consistent with a provided sample size, `n`.
    
    The library does not, in general, assume that the sample size of the data being analyzed is known. This introduces a number of problems around how to calculate statistics that are a function of the sample size.
    
    To address this problem, the library asks the user to provide `n`, an estimate of the true sample size based on their own beliefs about the data or a previous differentially private count of the number of rows in the data. This component then either subsamples or appends to the data in order to make it consistent with the provided `n`.
    
    :param data: The data to be resized.
    :param n: An estimate of the number of rows in the data. This could be the guess of the user, or the result of a DP release.
    :param lower: A lower bound on data elements for each column.
    :param upper: An upper bound on data elements for each column.
    :param categories: The set of categories you want to be represented for each column of the data, if the data is categorical.
    :param weights: Optional. The weight of each category when imputing. Uniform weights are used if not specified.
    :param distribution: The distribution to be used when imputing records.
    :param shift: The expectation of the Gaussian distribution used for imputation (used only if `distribution = Gaussian`).
    :param scale: The standard deviation of the Gaussian distribution used for imputation (used only if `distribution = Gaussian`).
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: A resized version of data consistent with the provided `n`
    """
    return Component(
        "Resize",
        arguments={
            'data': Component.of(data),
            'n': Component.of(n),
            'lower': Component.of(lower),
            'upper': Component.of(upper),
            'categories': Component.of(categories, value_format="jagged"),
            'weights': Component.of(weights, value_format="jagged"),
            'distribution': Component.of(distribution),
            'shift': Component.of(shift),
            'scale': Component.of(scale)
        },
        options={
            
        },
        constraints=kwargs)


def row_max(left, right, **kwargs):
    """
    RowMax Component
    
    Returns the maximum of the left and right arguments, per row.
    
    :param left: 
    :param right: 
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: 
    """
    return Component(
        "RowMax",
        arguments={
            'left': Component.of(left),
            'right': Component.of(right)
        },
        options={
            
        },
        constraints=kwargs)


def row_min(left, right, **kwargs):
    """
    RowMin Component
    
    Returns the minimum of the left and right arguments, per row.
    
    :param left: 
    :param right: 
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: 
    """
    return Component(
        "RowMin",
        arguments={
            'left': Component.of(left),
            'right': Component.of(right)
        },
        options={
            
        },
        constraints=kwargs)


def simple_geometric_mechanism(data, lower, upper, privacy_usage=None, enforce_constant_time=False, **kwargs):
    """
    SimpleGeometricMechanism Component
    
    Privatizes a result by returning it perturbed with Geometric noise.
    
    :param data: Result to be released privately via the Geometric mechanism.
    :param lower: 
    :param upper: 
    :param privacy_usage: Object describing the type and amount of privacy to be used for the mechanism release.
    :param enforce_constant_time: 
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: Original data perturbed with Geometric noise.
    """
    return Component(
        "SimpleGeometricMechanism",
        arguments={
            'data': Component.of(data),
            'lower': Component.of(lower),
            'upper': Component.of(upper)
        },
        options={
            'privacy_usage': serialize_privacy_usage(privacy_usage),
            'enforce_constant_time': enforce_constant_time
        },
        constraints=kwargs)


def subtract(left, right, **kwargs):
    """
    Subtract Component
    
    :param left: 
    :param right: 
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: 
    """
    return Component(
        "Subtract",
        arguments={
            'left': Component.of(left),
            'right': Component.of(right)
        },
        options={
            
        },
        constraints=kwargs)


def sum(data, **kwargs):
    """
    Sum Component
    
    Calculates the sum of each column of the data.
    
    :param data: Data for which you want the sum of each column.
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: Sum of each column of the data.
    """
    return Component(
        "Sum",
        arguments={
            'data': Component.of(data)
        },
        options={
            
        },
        constraints=kwargs)


def to_bool(data, true_label, **kwargs):
    """
    ToBool Component
    
    Cast data to a bool atomic type.
    
    :param data: Data to be cast to another type.
    :param true_label: Positive class (class to be mapped to `true`) for each column.
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: 
    """
    return Component(
        "ToBool",
        arguments={
            'data': Component.of(data),
            'true_label': Component.of(true_label)
        },
        options={
            
        },
        constraints=kwargs)


def to_float(data, **kwargs):
    """
    ToFloat Component
    
    Cast data to a float atomic type.
    
    :param data: Data to be cast to another type.
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: 
    """
    return Component(
        "ToFloat",
        arguments={
            'data': Component.of(data)
        },
        options={
            
        },
        constraints=kwargs)


def to_int(data, lower, upper, **kwargs):
    """
    ToInt Component
    
    Cast data to a int atomic type.
    
    :param data: Data to be cast to another type.
    :param lower: Minimum allowable imputation value. Integers cannot represent null, so values that cannot be parsed are imputed.
    :param upper: Maximum allowable imputation value.
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: 
    """
    return Component(
        "ToInt",
        arguments={
            'data': Component.of(data),
            'lower': Component.of(lower),
            'upper': Component.of(upper)
        },
        options={
            
        },
        constraints=kwargs)


def to_string(data, **kwargs):
    """
    ToString Component
    
    Cast data to a string atomic type.
    
    :param data: Data to be cast to another type.
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: 
    """
    return Component(
        "ToString",
        arguments={
            'data': Component.of(data)
        },
        options={
            
        },
        constraints=kwargs)


def variance(data, finite_sample_correction=True, **kwargs):
    """
    Variance Component
    
    Calculates the sample variance for each column of the data.
    
    :param data: 
    :param finite_sample_correction: Whether or not to use the finite sample correction (Bessel's correction).
    :param kwargs: clamp by lower, upper, categories, etc by passing parameters of the form [argument]_[bound]=...
    :return: Sample variance for each column of the data.
    """
    return Component(
        "Variance",
        arguments={
            'data': Component.of(data)
        },
        options={
            'finite_sample_correction': finite_sample_correction
        },
        constraints=kwargs)


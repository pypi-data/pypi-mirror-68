import typing as t
import logging
import pathlib
import contextlib
from egoist import types
from egoist.internal.prestringutil import output, Module
from egoist.go.resolver import Resolver, get_resolver
from egoist.langhelpers import get_path_from_function_name

from egoist.generators.structkit import runtime

logger = logging.getLogger(__name__)


def walk(fns: t.Dict[str, types.Command], *, root: t.Union[str, pathlib.Path]) -> None:
    with output(root=str(root), opener=Module, verbose=True) as fs:
        c = runtime.get_self()

        for name, fn in fns.items():
            logger.debug("walk %s", name)

            fpath = get_path_from_function_name(name)

            with fs.open(str(pathlib.Path(fpath)) + ".go", "w") as m:  # type: Module
                env = runtime.Env(m=m, fn=fn)  # xxx:
                c.stack.append(env)
                fn()
                c.stack.pop()


@contextlib.contextmanager
def structkit(
    env: runtime.Env,
    classes: t.List[t.Type[t.Any]],
    *,
    resolver: t.Optional[Resolver] = None,
) -> t.Iterator[Module]:
    from egoist.go.types import get_gopackage
    from egoist.generators.structkit import _walk
    from egoist.generators.structkit import _emit
    from egoist.generators.structkit import _context

    m = env.m
    resolver = resolver or get_resolver(m)
    ctx = _context.Context(m=m, resolver=resolver)

    yield m
    m.import_("")
    m.stmt(f"// this file is generated by {__name__}")
    m.sep()

    for item in _walk.walk(ctx, classes):
        gopackage = get_gopackage(item.type_)
        if gopackage is not None:
            continue

        if item.is_enums:
            _emit.emit_enums(ctx, item.type_)
            m.sep()
        elif item.is_union:
            _emit.emit_union(ctx, item)
            m.sep()
        else:
            _emit.emit_struct(ctx, item)
            m.sep()
            if item.fields:
                _emit.emit_unmarshalJSON(ctx, item)
            m.sep()
    return m

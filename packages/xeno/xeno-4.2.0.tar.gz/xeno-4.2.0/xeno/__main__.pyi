# Stubs for xeno.__main__ (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from typing import Any, Optional

class InjectionError(Exception): ...

class MissingResourceError(InjectionError):
    name: Any = ...
    def __init__(self, name: Any) -> None: ...

class MissingDependencyError(InjectionError):
    name: Any = ...
    dep_name: Any = ...
    def __init__(self, name: Any, dep_name: Any) -> None: ...

class MethodInjectionError(InjectionError):
    method: Any = ...
    name: Any = ...
    def __init__(self, method: Any, name: Any, reason: Optional[Any]=...) -> None: ...

class ClassInjectionError(InjectionError):
    class_: Any = ...
    name: Any = ...
    def __init__(self, class_: Any, name: Any, reason: Optional[Any]=...) -> None: ...

class CircularDependencyError(InjectionError):
    resource: Any = ...
    dep: Any = ...
    def __init__(self, resource: Any, dep: Any) -> None: ...

class UndefinedNameError(InjectionError):
    name: Any = ...
    def __init__(self, name: Any) -> None: ...

class UnknownNamespaceError(InjectionError):
    name: Any = ...
    def __init__(self, name: Any) -> None: ...

class InvalidResourceError(InjectionError): ...

class Attributes:
    attr_map: Any = ...
    def __init__(self) -> None: ...
    @staticmethod
    def for_object(obj: Any, create: bool=..., write: bool=..., factory: Any=...) -> Any: ...
    def put(self, attr: Any, value: bool=...) -> Any: ...
    def get(self, attr: Any, default_value: Any=...) -> Any: ...
    def check(self, attr: Any) -> Any: ...
    def merge(self, attr: Any) -> Any: ...

class ClassAttributes(Attributes):
    @staticmethod
    def for_class(class_: Any, create: bool=..., write: bool=...) -> Any: ...
    @staticmethod
    def for_object(obj: Any, create: bool=..., write: bool=...) -> Any: ...
    def __init__(self, class_: Any) -> None: ...

class MethodAttributes(Attributes):
    @staticmethod
    def for_method(f: Any, create: bool=..., write: bool=...) -> Any: ...
    @staticmethod
    def wraps(f1: Any) -> Any: ...
    @staticmethod
    def add(name: Any, value: bool=...) -> Any: ...
    def __init__(self, f: Any) -> None: ...

class Namespace:
    ROOT: str = ...
    SEP: str = ...
    @staticmethod
    def join(*args: Any) -> Any: ...
    @staticmethod
    def root() -> None: ...
    @staticmethod
    def leaf_name(name: Any) -> Any: ...
    name: Any = ...
    sub_namespaces: Any = ...
    leaves: Any = ...
    def __init__(self, name: Any) -> None: ...
    def add(self, name: Any) -> None: ...
    def add_namespace(self, name: Any) -> None: ...
    def get_namespace(self, name: Optional[Any]=...) -> Any: ...
    def get_leaves(self, recursive: bool=..., prefix: str=...) -> Any: ...

async def async_map(key: Any, coro: Any) -> Any: ...
async def async_wrap(f: Any, *args: Any, **kwargs: Any) -> Any: ...
def singleton(f: Any) -> Any: ...
def provide(f: Any) -> Any: ...
def inject(f: Any) -> Any: ...
def named(name: Any) -> Any: ...
def alias(alias: Any, name: Any) -> Any: ...
def namespace(name: Any) -> Any: ...
def const(name: Any, value: Any) -> Any: ...
def using(name: Any) -> Any: ...
def scan_methods(obj: Any, filter_f: Any) -> None: ...
def get_injection_points(obj: Any) -> Any: ...
def get_providers(obj: Any) -> Any: ...
def get_injection_params(f: Any, unbound_ctor: bool=...) -> Any: ...

class Injector:
    loop: Any = ...
    resources: Any = ...
    singletons: Any = ...
    dep_graph: Any = ...
    injection_interceptors: Any = ...
    async_injection_interceptors: Any = ...
    ns_index: Any = ...
    resource_attrs: Any = ...
    def __init__(self, *modules: Any) -> None: ...
    def get_namespace(self, name: Optional[Any]=...) -> Any: ...
    def add_module(self, module: Any, skip_cycle_check: bool=...) -> None: ...
    def add_injection_interceptor(self, interceptor: Any) -> None: ...
    def add_async_injection_interceptor(self, interceptor: Any) -> None: ...
    def create(self, class_: Any) -> Any: ...
    async def create_async(self, class_: Any) -> Any: ...
    def inject(self, obj: Any, aliases: Any=..., namespace: str=...) -> Any: ...
    async def inject_async(self, obj: Any, aliases: Any=..., namespace: str=...) -> Any: ...
    def require(self, name: Any, method: Optional[Any]=...) -> Any: ...
    async def require_async(self, name: Any, method: Optional[Any]=...) -> Any: ...
    async def provide_async(self, name: Any, value: Any, is_singleton: bool=..., namespace: Optional[Any]=...) -> Any: ...
    def provide(self, name: Any, value: Any, is_singleton: bool=..., namespace: Optional[Any]=...) -> Any: ...
    def has(self, name: Any) -> Any: ...
    def get_dependency_tree(self, resource_name: Any) -> Any: ...
    def get_dependency_graph(self, resource_name: Any, *other_resource_names: Any) -> Any: ...
    def get_dependencies(self, resource_name: Any) -> Any: ...
    def get_resource_attributes(self, resource_name: Any) -> Any: ...
    def scan_resources(self, filter_f: Any) -> None: ...
    def unbind_singleton(self, resource_name: Optional[Any]=..., unbind_all: bool=...) -> None: ...
    def check_for_cycles(self) -> None: ...

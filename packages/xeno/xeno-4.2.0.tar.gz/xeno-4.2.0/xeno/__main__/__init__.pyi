# Stubs for __main__ (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from typing import Any, Optional

class InjectionError(Exception): ...

class MissingResourceError(InjectionError):
    name: Any = ...
    def __init__(self, name: Any) -> None: ...

class MissingDependencyError(InjectionError):
    name: Any = ...
    dep_name: Any = ...
    def __init__(self, name: Any, dep_name: Any) -> None: ...

class MethodInjectionError(InjectionError):
    method: Any = ...
    name: Any = ...
    def __init__(self, method: Any, name: Any, reason: Optional[Any] = ...) -> None: ...

class ClassInjectionError(InjectionError):
    class_: Any = ...
    name: Any = ...
    def __init__(self, class_: Any, name: Any, reason: Optional[Any] = ...) -> None: ...

class CircularDependencyError(InjectionError):
    resource: Any = ...
    dep: Any = ...
    def __init__(self, resource: Any, dep: Any) -> None: ...

class UndefinedNameError(InjectionError):
    name: Any = ...
    def __init__(self, name: Any) -> None: ...

class UnknownNamespaceError(InjectionError):
    name: Any = ...
    def __init__(self, name: Any) -> None: ...

class InvalidResourceError(InjectionError): ...

class Attributes:
    attr_map: Any = ...
    def __init__(self) -> None: ...
    @staticmethod
    def for_object(obj: Any, create: bool = ..., write: bool = ..., factory: Any = ...): ...
    def put(self, attr: Any, value: bool = ...): ...
    def get(self, attr: Any, default_value: Any = ...): ...
    def check(self, attr: Any): ...
    def merge(self, attr: Any): ...

class ClassAttributes(Attributes):
    @staticmethod
    def for_class(class_: Any, create: bool = ..., write: bool = ...): ...
    @staticmethod
    def for_object(obj: Any, create: bool = ..., write: bool = ...): ...
    def __init__(self, class_: Any) -> None: ...

class MethodAttributes(Attributes):
    @staticmethod
    def for_method(f: Any, create: bool = ..., write: bool = ...): ...
    @staticmethod
    def wraps(f1: Any): ...
    @staticmethod
    def add(name: Any, value: bool = ...): ...
    def __init__(self, f: Any) -> None: ...

class Namespace:
    ROOT: str = ...
    SEP: str = ...
    @staticmethod
    def join(*args: Any): ...
    @staticmethod
    def root(): ...
    @staticmethod
    def leaf_name(name: Any): ...
    name: Any = ...
    sub_namespaces: Any = ...
    leaves: Any = ...
    def __init__(self, name: Any) -> None: ...
    def add(self, name: Any) -> None: ...
    def add_namespace(self, name: Any) -> None: ...
    def get_namespace(self, name: Optional[Any] = ...): ...
    def get_leaves(self, recursive: bool = ..., prefix: str = ...): ...

async def async_map(key: Any, coro: Any): ...
async def async_wrap(f: Any, *args: Any, **kwargs: Any): ...
def singleton(f: Any): ...
def provide(f: Any): ...
def inject(f: Any): ...
def named(name: Any): ...
def alias(alias: Any, name: Any): ...
def namespace(name: Any): ...
def const(name: Any, value: Any): ...
def using(name: Any): ...
def scan_methods(obj: Any, filter_f: Any) -> None: ...
def get_injection_points(obj: Any): ...
def get_providers(obj: Any): ...
def get_injection_params(f: Any, unbound_ctor: bool = ...): ...

class Injector:
    loop: Any = ...
    resources: Any = ...
    singletons: Any = ...
    dep_graph: Any = ...
    injection_interceptors: Any = ...
    async_injection_interceptors: Any = ...
    ns_index: Any = ...
    resource_attrs: Any = ...
    def __init__(self, *modules: Any) -> None: ...
    def get_namespace(self, name: Optional[Any] = ...): ...
    def add_module(self, module: Any, skip_cycle_check: bool = ...) -> None: ...
    def add_injection_interceptor(self, interceptor: Any) -> None: ...
    def add_async_injection_interceptor(self, interceptor: Any) -> None: ...
    def create(self, class_: Any): ...
    async def create_async(self, class_: Any): ...
    def inject(self, obj: Any, aliases: Any = ..., namespace: str = ...): ...
    async def inject_async(self, obj: Any, aliases: Any = ..., namespace: str = ...): ...
    def require(self, name: Any, method: Optional[Any] = ...): ...
    async def require_async(self, name: Any, method: Optional[Any] = ...): ...
    async def provide_async(self, name: Any, value: Any, is_singleton: bool = ..., namespace: Optional[Any] = ...): ...
    def provide(self, name: Any, value: Any, is_singleton: bool = ..., namespace: Optional[Any] = ...): ...
    def has(self, name: Any): ...
    def get_dependency_tree(self, resource_name: Any): ...
    def get_dependency_graph(self, resource_name: Any, *other_resource_names: Any): ...
    def get_dependencies(self, resource_name: Any): ...
    def get_resource_attributes(self, resource_name: Any): ...
    def scan_resources(self, filter_f: Any) -> None: ...
    def unbind_singleton(self, resource_name: Optional[Any] = ..., unbind_all: bool = ...) -> None: ...
    def check_for_cycles(self): ...
